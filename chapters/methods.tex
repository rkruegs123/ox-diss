\chapter[Methods]{Methods} \label{ch:methods}

At a high level, the goal of any quantum circuit optimization is to reduce the complexity of the input circuit.
A core assumption of circuit optimization in the ZX-calculus is that ZX-diagrams with fewer spiders typically correspond to simpler circuits.
Earlier, however, we noted that local changes (e.g., connectivity) in a ZX-diagram can drastically affect the complexity of the associated circuit obtained via extraction.
However, no existing optimization procedure over ZX-diagrams addresses this and searches this local space.
The \codeword{full_reduce} method described in Section \ref{sec:zx-circ-opt} is the quintessential example of this lost opportunity.
After the two simplification rules can no longer be applied, the final circuit is taken to be that which is extracted from the resulting simplified ZX-diagram;
however, there may be an equivalent ZX-diagram lurking nearby whose associated circuit is markedly less complex.

In this thesis, we explore the utility of searching this local space of equivalent ZX-diagrams.
To do so, we first need rewrite rules that modify a ZX-diagram in a manner other than spider removal that may reduce circuit complexity.
Indeed, a rule that introduces several additional spiders alongside changes in connectivity may in turn yield a less complex circuit.
We refer to these rewrite rules as \emph{congruences}.
Given a set of congruences, we then need a procedure to search the space of equivalent ZX-diagrams generated by an input ZX-diagram and these rules.
We can then devise strategies for incorporating this local search into existing methods for circuit optimization in the ZX-calculus.

We present the methods of our work in this order.
First, we generalize the original (non-simplification) variants of local complementation and pivoting to ZX-diagrams with arbitrary phases.
We then describe two search procedures, simulated annealing (SA) and genetic algorithms (GA), for searching the space of ZX-diagrams generated by these congruences.
We also define a measure of circuit complexity and discuss candidate objective functions to guide search. % to the ZX-diagram whose circuit has minimal complexity.
Lastly, we discuss how this search can be incorporated into existing optimization pipelines.
Our primary strategy is to first simplify a ZX-diagram using existing methods and subsequently search the local variants of the simplified ZX-diagram.
Alternatively, we can use SA or GA as the principal means of optimization.
In this more ambitious approach, congruences can be combined with simplification rules to form an action set over which search is applied.

\section{Congruences}\label{sec:congruences}

The non-simplification versions of local complementation and pivoting presented in Section \ref{sec:zx-circ-opt} embody the desired properties of congruences.
They change the connectivity of the ZX-diagram without introducing an unwieldy number of additional gates, presenting an opportunity for a potential reduction in circuit complexity.
However, Equations \ref{eq:gs-local-comp} and \ref{eq:gs-pivot} only apply to spiders with zero phase and a single wire.

% Useful for spacing:
% https://tex.stackexchange.com/questions/54587/vertical-spacing-within-align-environment-accounting-for-fractions
We can apply the rules of the ZX-calculus and Equation \ref{eq:gs-local-comp} to generalize local complementation to arbitrary phases ($\alpha_i, \beta_i \in [0, 2 \pi)$):
% {\allowdisplaybreaks
\begin{spreadlines}{0.8em}% tweak
  \begin{align*}
    \tikzfig{gen-lc-single/0} &\stackrel{(\bm f)}{=} \tikzfig{gen-lc-single/1} \\
    &\stackrel{(\ref{eq:gs-local-comp})}{=} \tikzfig{gen-lc-single/2} \\
    &\stackrel{(\bm i1)}{=} \tikzfig{gen-lc-single/3} \\
    &\stackrel{(\bm f)}{=} \tikzfig{gen-lc-single/4} \\
    &\stackrel{(\bm f)}{=} \tikzfig{gen-lc-single/5} \\[0.8em]
    &\stackrel{(\ref{eq:had-short})}{=} \tikzfig{gen-lc-single/6}\stepcounter{equation}\tag{\theequation}\label{eq:gen-phase-lc}
  \end{align*}
\end{spreadlines}
% }
Equation \ref{eq:gen-phase-lc} can be easily extended to apply for an arbitrary number of wires connected to each spider:
% {\allowdisplaybreaks
\begin{spreadlines}{0.8em}% tweak
  \begin{align*}
    \tikzfig{gen-lc-mul/0} &\stackrel{(\bm f)}{=} \tikzfig{gen-lc-mul/1} \\
    &\stackrel{(\ref{eq:gen-phase-lc})}{=} \tikzfig{gen-lc-mul/2} \\
    &\stackrel{(\bm f)}{=} \tikzfig{gen-lc-mul/3}\stepcounter{equation}\tag{\theequation}\label{eq:gen-io-lc}
  \end{align*}
\end{spreadlines}
% }
% Equation \ref{eq:gs-pivot}:
Similarly, we can generalize pivoting to arbitrary phases:
% {\allowdisplaybreaks
\begin{spreadlines}{0.8em}% tweak
  \begin{align*}
    \tikzfig{gen-pivot-single/0} &\stackrel{(\bm f)}{=} \tikzfig{gen-pivot-single/1} \\
    &\stackrel{(\ref{eq:gs-pivot})}{=} \tikzfig{gen-pivot-single/2} \\
    &\stackrel{(\bm f)}{=} \tikzfig{gen-pivot-single/3}\stepcounter{equation}\tag{\theequation}\label{eq:gen-phase-pivot}
  \end{align*}
\end{spreadlines}
% }
Again, we can extend this rewrite rule for arbitrary wiring:
\begin{spreadlines}{0.8em}% tweak
  \begin{align*}
    \tikzfig{gen-pivot-mul/0} &\stackrel{(\bm f)}{=} \tikzfig{gen-pivot-mul/1} \\
    &\stackrel{(\ref{eq:gen-phase-pivot})}{=} \tikzfig{gen-pivot-mul/2} \\
    &\stackrel{(\bm f)}{=} \tikzfig{gen-pivot-mul/3}\stepcounter{equation}\tag{\theequation}\label{eq:gen-io-pivot}
  \end{align*}
\end{spreadlines}
% Equations \ref{eq:gen-io-lc} and \ref{eq:gen-io-pivot} will serve as our primary congruences -- those rewrite rules that, when applied, maintain a similar graph complexity but potentially reduce the circuit complexity.
Equations \ref{eq:gen-io-lc} and \ref{eq:gen-io-pivot} will serve as our primary congruences because they maintain a similar graph complexity (e.g., number of spiders and wires) but, due to their effects on connectivity, can produce circuits of varying complexities.
Equation \ref{eq:gen-io-lc} can be applied to any spider with a degree of more than 1.
Equation \ref{eq:gen-io-pivot} can be applied to any pair of connected spiders.


\section{Search Procedures}

The space of ZX-diagrams generated by an input ZX-diagram and these congruences is combinatorial and therefore cannot be searched exhaustively.
We can instead formulate this search as an optimization problem where the set of isomorphic ZX-diagrams are the states (reachable by congruence applications) that are evaluated by some quantitative measure of circuit complexity.
Here we describe two search procedures as well as several candidate objective functions that either measure circuit complexity directly or use ZX-diagrammatic properties as a proxy.

\subsection{Simulated Annealing}\label{sec:sa}

Simulated annealing is an optimization technique named after the annealing process in metallurgy in which a molten hot metal is cooled in a slow, controlled fashion in order for it to reach its most stable form.
In SA, this notion of slow cooling is interpreted as a slow decrease in the probability of accepting worse solutions.
In this way, the algorithm initially explores a broad region of the the search space and progressively narrows its scope.

More formally, the SA algorithm maintains a current state $s$ and at each step randomly considers some neighboring state $s^*$.
The algorithm then chooses whether or not to replace $s$ with $s^*$ via a Bernoulli random variable parameterized by the \emph{acceptance probability}, denoted $P(s, s^*, T)$. % FIXME: wrong subject for "denoted"?
The acceptance probability depends on (1) the \emph{energy} (i.e., objective) \emph{function}, and (2) the \emph{temperature}.
The energy function $E(s)$ assigns a score to each state (lower is better).
If $E(s') < E(s)$, then $s$ is always replaced with $s^*$ (i.e., $P(s, s^*, T) = 1$).
Otherwise, $P(s, s^*, T) = exp(-\frac{E(s^*) - E(s)}{T})$ where the temperature $T$ controls the likelihood of moving to a higher energy state.
Note that $P(s, s^*, T)$ is inversely proportional to $E(s^*) - E(s)$ and directly proportional to $T$.
Informally, this means that $s^*$ is more likely to be accepted if it is closer in energy to $s$ and with a higher temperature.
$T$ is initialized to some positive value and progressively decreases to zero.
At each step, $T$ is updated as $T = T * c$ where $c \in [0, 1)$ is the \emph{cooling} parameter. % FIXME: Change in code to always cool, not just when a change is made.
In this way, SA converges towards a greedy algorithm and is more likely to accept $s^*$ when $E(s^*) > E(s)$ early in search when $T$ is high.
The algorithm terminates when a maximum number of steps $k_{max}$ is reached.
Algorithm \ref{alg:sa} provides an overview of this procedure.

\begin{algorithm}[t]
  \caption{Simulated annealing
    \label{alg:sa}}
  \begin{algorithmic}[1]
    % \Require{$x$ and $y$ are packed \DNA{} strings of equal length $n$}
    % \Statex
    \Function{SimAnneal}{$s_0, T, c, k_{max}$}
      % \Let{$z$}{$x \oplus y$} \Comment{$\oplus$: bitwise exclusive-or}
      \Let{$s$}{$s_0$}
      \For{$i \gets 0 \textrm{ to } k_{max}$}
        \Let{$s^*$}{randomly sampled neighbor of $s$}
        \If{$E(s^*) < E(s)$ {\bf or} $\text{random}(0, 1) < exp(-\frac{E(s^*) - E(s)}{T})$}
          \Let{$s$}{$s^*$}
        \EndIf
        \Let{$T$}{$T * c$}
      \EndFor
      \State \Return{$s$}
    \EndFunction
  \end{algorithmic}
\end{algorithm}

In this work, the state is a ZX-diagram and neighbors are sampled via the probabilistic application of rewrite rules.
For example, to anneal using the rewrite rules described in Section \ref{sec:congruences}, $s^*$ would be sampled by first choosing one of Equation \ref{eq:gen-io-lc} or Equation \ref{eq:gen-io-pivot} and then choosing a spider or pair of connected spiders to which the rule will be applied.
Note that we use Equations \ref{eq:gen-io-lc} and \ref{eq:gen-io-pivot} by default but in theory any set of rewrite rules can be used.

\subsection{Genetic Algorithms}

Genetic algorithms are a class of optimization procedures inspired by the process of natural selection.
Rather than maintaining a single state (e.g., as in SA), a \emph{population} of candidate solutions is \emph{evolved}.
This evolution is guided by a \emph{fitness function} and operates via biologically inspired notions of \emph{mutation}, \emph{crossover}, and \emph{selection}.
In this work, we define fitness such that lower fitness is better to remain consistent with the energy function described in Section \ref{sec:sa}.
For details on objective functions used to guide circuit optimization, see Section \ref{sec:obj-funcs}.

A genetic algorithm operates in the following general fashion.
First, a population of candidate solutions, commonly referred to as \emph{mutants}, is randomly generated.
The population size is typically fixed to some $n_{mutants}$.
This initial population then evolves in a series of \emph{generations}.
Each generation consists of two parts: (1) selection and (2) application of genetic operators (e.g., mutation and crossover).
In the selection step, a score is assigned to each mutant via the fitness function and a new population is chosen given these scores.
For example, a naive selection method would set the population to $n_{mutants}$ copies of the best-scoring mutant.
Given this surviving population, the second step involves applying genetic operators to obtain a revised, diverse population (and therefore search the solution space).
The two most common genetic operators are mutation and crossover.
Analogous to mistakes being made during replication of a DNA sequence, a mutation operator involves randomly tweaking a single mutant.
In the case where mutants are represented as bit strings, the canonical example of a mutation operator is a bit-flip.
Alternatively, a crossover operator produces a new mutant given two or more existing mutants;
this is analogous to reproduction and biological crossover.
For example, given two mutants represented as strings, a new mutant can be generated by swapping the two segments defined by a random position.
Evolution proceeds for $n_{gens}$ generations and the algorithm returns the mutant with the highest fitness throughout search.
This process is summarized in Figure \ref{fig:ga}.

\begin{figure}
\centering
\tikzfig{ga}
\caption{An overview of genetic algorithms.}
\label{fig:ga}
\end{figure}

% \ctikzfig{ga}

\iffalse
\begin{figure}[t]
\centering
\includegraphics[width=8cm]{img/tournament.png}
\caption{An overview of the simple variant of tournament selection used in this work.
  Two mutants are randomly chosen and the winner with better fitness is selected.}
\label{fig:tourn}
\end{figure}
\fi

In this work, mutants are represented as ZX-diagrams and mutation operators are rewrite rules.
As is common in practical applications of genetic algorithms, we do not use any crossover operators though this is an attractive area for future exploration given the graphical nature of ZX-diagrams. % FIXME: cite
Lastly, we use \emph{tournament selection} to determine the surviving mutants at each generation.
In this selection method, $k_{tourn}$ mutants are selected to compete in a ``tournament'' from which a winner is chosen based on fitness.
This is repeated $n_{mutants}$ times with replacement to obtain a surviving population.
We use a simple variant of tournament selection in which $k_{tourn} = 2$ and the winner is simply the mutant with better (i.e., lower) fitness.


\subsection{Objective Functions}\label{sec:obj-funcs}

% Both energy and fitness functions described above are instances of objective functions. In both cases, lower is better. From here, we use objective function to refer to either.

TODO: weighted 2-qubit gates, number of edges, etc. Note that they're not normalized.
% when making distinction of ones that are just at graph-level, to make it clear that its for performance, have to say that only state that has to be tracked is ZX-diagram. Not sure if this should be commented on in above section (note: already added "by default" to TS).

% look up ion trap papers, single qubit gates with 99.9 fidelity and two qubit with 99 fidelity. 10 perc difference in fidelity. chris ballance

\section{Circuit Optimization Strategies}

TODO: Here we describe how we use conruences and these search procedures for quantum circuit optimization. First describe primary method: searching local space after simplification. Then describe several other variants.

FIXME: Other, more general combinations (e.g., GA with all simps, or search with other ``safe'' procedures). Maybe simplifying to fixpoint isn't optimal, and introduces too many edges that lead to CNOTs to get us marginal T-count gain.

% subsection: after ZX-diagram reduction. try different reductions. Post-Simplification of ZX-Diagram

% subsection: from scratch. just include congruences as a possible action along with all the others
% In this work, mutants are represented as pairs of ZX-diagrams and their associated circuits by default.
% This allows for mutation to occur at either the graph- or circuit-level.
% If a mutant is modified at the graph-level (i.e., via a rewrite rule), the associated circuit is obtained via extraction.
% Alternatively, traditional circuit-level optimizations can be applied and the correpsonding ZX-diagram can be generated directly from the modified circuit..
