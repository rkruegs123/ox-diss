\chapter[Methods]{Methods} \label{ch:methods}

At a high level, the goal of any quantum circuit optimization is to reduce the complexity of the input circuit.
A core assumption of circuit optimization in the ZX-calculus is that ZX-diagrams with fewer spiders typically correspond to simpler circuits.
Earlier, however, we noted that local changes (e.g., connectivity) in a ZX-diagram can drastically affect the complexity of the associated circuit obtained via extraction.
However, no existing optimization procedure over ZX-diagrams addresses this and searches this local space.
The \codeword{full_reduce} method described in Section \ref{sec:zx-circ-opt} is the quintessential example of this lost opportunity.
After the two simplification rules can no longer be applied, the final circuit is taken to be that which is extracted from the resulting simplified ZX-diagram;
however, there may be an equivalent ZX-diagram lurking nearby whose associated circuit is markedly less complex.

In this thesis, we explore the utility of searching this local space of equivalent ZX-diagrams.
To do so, we first need rewrite rules that modify a ZX-diagram in a manner other than spider removal that may reduce circuit complexity.
Indeed, a rule that introduces several additional spiders alongside changes in connectivity may in turn yield a less complex circuit.
We refer to these rewrite rules as \emph{congruences}.
Given a set of congruences, we then need a procedure to search the space of equivalent ZX-diagrams generated by an input ZX-diagram and these rules.
We can then devise strategies for incorporating this local search into existing methods for circuit optimization in the ZX-calculus.

We present the methods of our work in this order.
First, we generalize the original (non-simplification) variants of local complementation and pivoting to ZX-diagrams with arbitrary phases.
We then describe two search procedures, simulated annealing (SA) and genetic algorithms (GA), for searching the space of ZX-diagrams generated by these congruences.
We also define a measure of circuit complexity and discuss candidate objective functions to guide search. % to the ZX-diagram whose circuit has minimal complexity.
Lastly, we discuss how this search can be incorporated into existing optimization pipelines.
Our primary strategy is to first simplify a ZX-diagram using existing methods and subsequently search the local variants of the simplified ZX-diagram.
Alternatively, we can use SA or GA as the principal means of optimization.
In this more ambitious approach, congruences can be combined with simplification rules to form an action set over which search is applied.

\section{Congruences}\label{sec:congruences}

The non-simplification versions of local complementation and pivoting presented in Section \ref{sec:zx-circ-opt} embody the desired properties of congruences.
They change the connectivity of the ZX-diagram without introducing an unwieldy number of additional gates, presenting an opportunity for a potential reduction in circuit complexity.
However, Equations \ref{eq:gs-local-comp} and \ref{eq:gs-pivot} only apply to spiders with zero phase and a single wire.

% Useful for spacing:
% https://tex.stackexchange.com/questions/54587/vertical-spacing-within-align-environment-accounting-for-fractions
We can apply the rules of the ZX-calculus and Equation \ref{eq:gs-local-comp} to generalize local complementation to arbitrary phases ($\alpha_i, \beta_i \in [0, 2 \pi)$):
% {\allowdisplaybreaks
\begin{spreadlines}{0.8em}% tweak
  \begin{align*}
    \tikzfig{gen-lc-single/0} &\stackrel{(\bm f)}{=} \tikzfig{gen-lc-single/1} \\
    &\stackrel{(\ref{eq:gs-local-comp})}{=} \tikzfig{gen-lc-single/2} \\
    &\stackrel{(\bm i1)}{=} \tikzfig{gen-lc-single/3} \\
    &\stackrel{(\bm f)}{=} \tikzfig{gen-lc-single/4} \\
    &\stackrel{(\bm f)}{=} \tikzfig{gen-lc-single/5} \\[0.8em]
    &\stackrel{(\ref{eq:had-short})}{=} \tikzfig{gen-lc-single/6}\stepcounter{equation}\tag{\theequation}\label{eq:gen-phase-lc}
  \end{align*}
\end{spreadlines}
% }
Equation \ref{eq:gen-phase-lc} can be easily extended to apply for an arbitrary number of wires connected to each spider:
% {\allowdisplaybreaks
\begin{spreadlines}{0.8em}% tweak
  \begin{align*}
    \tikzfig{gen-lc-mul/0} &\stackrel{(\bm f)}{=} \tikzfig{gen-lc-mul/1} \\
    &\stackrel{(\ref{eq:gen-phase-lc})}{=} \tikzfig{gen-lc-mul/2} \\
    &\stackrel{(\bm f)}{=} \tikzfig{gen-lc-mul/3}\stepcounter{equation}\tag{\theequation}\label{eq:gen-io-lc}
  \end{align*}
\end{spreadlines}
% }
% Equation \ref{eq:gs-pivot}:
Similarly, we can generalize pivoting to arbitrary phases:
% {\allowdisplaybreaks
\begin{spreadlines}{0.8em}% tweak
  \begin{align*}
    \tikzfig{gen-pivot-single/0} &\stackrel{(\bm f)}{=} \tikzfig{gen-pivot-single/1} \\
    &\stackrel{(\ref{eq:gs-pivot})}{=} \tikzfig{gen-pivot-single/2} \\
    &\stackrel{(\bm f)}{=} \tikzfig{gen-pivot-single/3}\stepcounter{equation}\tag{\theequation}\label{eq:gen-phase-pivot}
  \end{align*}
\end{spreadlines}
% }
Again, we can extend this rewrite rule for arbitrary wiring:
\begin{spreadlines}{0.8em}% tweak
  \begin{align*}
    \tikzfig{gen-pivot-mul/0} &\stackrel{(\bm f)}{=} \tikzfig{gen-pivot-mul/1} \\
    &\stackrel{(\ref{eq:gen-phase-pivot})}{=} \tikzfig{gen-pivot-mul/2} \\
    &\stackrel{(\bm f)}{=} \tikzfig{gen-pivot-mul/3}\stepcounter{equation}\tag{\theequation}\label{eq:gen-io-pivot}
  \end{align*}
\end{spreadlines}
% Equations \ref{eq:gen-io-lc} and \ref{eq:gen-io-pivot} will serve as our primary congruences -- those rewrite rules that, when applied, maintain a similar graph complexity but potentially reduce the circuit complexity.
Equations \ref{eq:gen-io-lc} and \ref{eq:gen-io-pivot} will serve as our primary congruences because they maintain a similar graph complexity (e.g., number of spiders and wires) but, due to their effects on connectivity, can produce circuits of varying complexities.
Equation \ref{eq:gen-io-lc} can be applied to any spider with a degree of more than 1.
Equation \ref{eq:gen-io-pivot} can be applied to any pair of connected spiders.


\section{Search Procedures}

The space of ZX-diagrams generated by an input ZX-diagram and these congruences is combinatorial and therefore cannot be searched exhaustively.
We can instead formulate this search as an optimization problem where the set of isomorphic ZX-diagrams are the states (reachable by congruence applications) that are evaluated by some quantitative measure of circuit complexity.
Here we describe two search procedures as well as several candidate objective functions that either measure circuit complexity directly or use ZX-diagrammatic properties as a proxy.

\subsection{Simulated Annealing}

Simulated annealing (SA) is an optimization technique named after the annealing process in metallurgy in which a molten hot metal is cooled in a slow, controlled fashion in order for it to reach its most stable form.
In SA, this notion of slow cooling is interpreted as a slow decrease in the probability of accepting worse solutions.
In this way, the algorithm initially explores a broad region of the the search space and progressively narrows its scope.

More formally, the SA algorithm maintains a current state $s$ and at each step randomly considers some neighboring state $s^*$.
The algorithm then chooses whether or not to replace $s$ with $s^*$ via a Bernoulli random variable parameterized by the \emph{acceptance probability}, denoted $P(s, s^*, T)$. % FIXME: wrong subject for "denoted"?
The acceptance probability depends on (1) the \emph{energy} (i.e., objective) \emph{function}, and (2) the \emph{temperature}.
The energy function $E(s)$ assigns a score to each state (lower is better).
If $E(s') < E(s)$, then $s$ is always replaced with $s^*$ (i.e., $P(s, s^*, T) = 1$).
Otherwise, $P(s, s^*, T) = exp(-\frac{E(s^*) - E(s)}{T})$ where the temperature $T$ controls the likelihood of moving to a higher energy state.
Note that $P(s, s^*, T)$ is inversely proportional to $E(s^*) - E(s)$ and directly proportional to $T$.
Informally, this means that $s^*$ is more likely to be accepted if it is closer in energy to $s$ and with a higher temperature.
$T$ is initialized to some positive value and progressively decreases to zero.
At each step, $T$ is updated as $T = T * c$ where $c \in [0, 1)$ is the \emph{cooling} parameter. % FIXME: Change in code to always cool, not just when a change is made.
In this way, SA converges towards a greedy algorithm and is more likely to accept $s^*$ when $E(s^*) > E(s)$ early in search when $T$ is high.
The algorithm terminates when a maximum number of steps $k_{max}$ is reached.
Algorithm \ref{alg:sa} provides an overview of this procedure.

\begin{algorithm}[t]
  \caption{Simulated annealing
    \label{alg:sa}}
  \begin{algorithmic}[1]
    % \Require{$x$ and $y$ are packed \DNA{} strings of equal length $n$}
    % \Statex
    \Function{SimAnneal}{$s_0, T, c, k_{max}$}
      % \Let{$z$}{$x \oplus y$} \Comment{$\oplus$: bitwise exclusive-or}
      \Let{$s$}{$s_0$}
      \For{$i \gets 0 \textrm{ to } k_{max}$}
        \Let{$s^*$}{randomly sampled neighbor of $s$}
        \If{$E(s^*) < E(s)$ {\bf or} $\text{random}(0, 1) < exp(-\frac{E(s^*) - E(s)}{T})$}
          \Let{$s$}{$s^*$}
        \EndIf
        \Let{$T$}{$T * c$}
      \EndFor
      \State \Return{$s$}
    \EndFunction
  \end{algorithmic}
\end{algorithm}

In this work, the state is a ZX-diagram and neighbors are sampled via the probabilistic application of rewrite rules.
For example, to anneal using the rewrite rules described in Section \ref{sec:congruences}, $s^*$ would be sampled by first choosing one of Equation \ref{eq:gen-io-lc} or Equation \ref{eq:gen-io-pivot} and then choosing a spider or pair of connected spiders to which the rule will be applied.
Note that we use Equations \ref{eq:gen-io-lc} and \ref{eq:gen-io-pivot} by default but in theory any set of rewrite rules can be used.

\subsection{Genetic Algorithms}

TODO

% Describe most general form first. Mutation and selection steps. No crossover (as is common). Then say in this work, mutation will be rewrite rules and we use tournament selection.

\subsection{Objective Functions}

TODO: weighted 2-qubit gates, number of edges, etc. Note that they're not normalized.

% look up ion trap papers, single qubit gates with 99.9 fidelity and two qubit with 99 fidelity. 10 perc difference in fidelity. chris ballance

\section{Circuit Optimization Strategies}

TODO: Here we describe how we use conruences and these search procedures for quantum circuit optimization. First describe primary method: searching local space after simplification. Then describe several other variants.

FIXME: Other, more general combinations (e.g., GA with all simps, or search with other ``safe'' procedures). Maybe simplifying to fixpoint isn't optimal, and introduces too many edges that lead to CNOTs to get us marginal T-count gain.

% subsection: after ZX-diagram reduction. try different reductions. Post-Simplification of ZX-Diagram

% subsection: from scratch. just include congruences as a possible action along with all the others.
